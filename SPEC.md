# Substitution Mapping Mixer – Specification

## 1. Purpose

Substitution Mapping Mixer is a web-based workbench for **manual analysis of substitution ciphers**.

This tool does NOT aim to automatically solve ciphers.
Instead, it provides a **thinking space** where humans can:

- Maintain partial mappings
- Hold ambiguous hypotheses
- Generate and compare multiple decoding branches
- Observe and refine substitutions visually

---

## 2. Input Text Rules

### 2.1 Character Semantics

| Character Type | Meaning |
|---|---|
| A–Z (uppercase) | Ciphertext character (undecoded) |
| a–z (lowercase) | Plaintext character (confirmed by user) |
| Non-letters | Preserved as-is |

- Uppercase and lowercase letters have **different semantic meanings**.
- Lowercase letters represent **confirmed plaintext written directly by the user**.

---

## 3. Substitution Mapping Model

### 3.1 Mapping Direction
- Cipher → Plain
- One-to-one (monoalphabetic substitution)

### 3.2 Mapping Types

Each cipher character may have:

#### Fixed Mapping
- Exactly one plaintext letter
- Example: `Q → e`

#### Candidate Mapping
- Multiple possible plaintext letters
- Example: `X → {y, m, n}`

#### Resolution Priority
1. If a fixed mapping exists, it is used
2. If only one candidate exists, it is automatically adopted as fixed
3. If multiple candidates exist, branch generation occurs

---

## 4. Monoalphabetic Constraints

The following states are considered **conflicts**:

- The same plaintext letter is fixed for multiple cipher letters
- A branch assigns the same plaintext letter to multiple cipher letters

Conflicts:
- Do NOT stop execution
- MUST be shown visually

---

## 5. Branching System

### 5.1 Definition

A **branch** is a fully fixed substitution table generated by selecting
one candidate for each cipher character that has candidates.

Example:
- `A → {i, a}`
- `X → {y, m, n}`

→ up to 6 branches (2 × 3), excluding conflicting combinations.

### 5.2 Branch Generation Rules

- Only cipher characters with **2 or more candidates** participate in branching
- Single-candidate entries are treated as fixed (no branching)
- Each branch selects exactly one candidate per branching character
- Branches violating monoalphabetic constraints are discarded
- No artificial limit on branch count
- If no valid branches exist, a "base mapping" is shown

### 5.3 Branch Labels

Each branch has a human-readable label listing only newly fixed mappings.

Example:
```
A=a, X=n
```

---

## 6. Decoding Output Rules

For each branch:

- Lowercase letters → output as-is (confirmed plaintext)
- Uppercase letters:
  - If fixed mapping exists → output mapped plaintext (green)
  - If single candidate exists → output that candidate (treated as fixed)
  - If multiple candidates exist → output undecoded marker `?`
  - If no mapping and no candidates → output original uppercase letter
- Non-letters → output as-is

### 6.1 Undecoded Marker

- Characters with multiple candidates are rendered as `?`
- Characters with no mapping at all retain their original uppercase form

---

## 7. Unused Plaintext Letters

### 7.1 Definition

A plaintext letter (a–z) is **unused** if:

- It is not used in any fixed mapping
- It does not appear as lowercase in the input text

### 7.2 States

Unused letters are categorized as:

1. Completely unused
2. Used only in candidate mappings
3. Used (hidden)

This list updates dynamically.

---

## 8. Mutual Highlighting

- Hovering a cipher letter in text highlights its row in the mapping table
- Hovering a mapping row highlights all occurrences of that cipher letter in text
- Hover-only interaction (no clicks)

---

## 9. Branch Difference Highlighting

Within each branch result:

- Characters affected by branch-specific mappings are visually emphasized
- Identical portions across branches are not emphasized

---

## 10. Terminology Consistency

UI and documentation MUST consistently use:

- Fixed
- Candidates
- Branches
- Unused

---

## 11. Design Philosophy (Non-Negotiable)

> This tool does not solve ciphers.
> It provides a stable board on which humans think.

Automatic scoring, ranking, or dictionary-based elimination
are explicitly out of scope.
